# Whole Genome Duplication Analyses

## Ks Plots

Compute Ks plots (paralog age distributions) with [wgd](https://github.com/arzwa/wgd) (Zwaenepoel and Van de Peer 2019). 

Run all-vs.-all Blastp analysis and cluster using MCL with the default parameters (e-value cut-off of 10^-10, inflation factor of 2.0). Make sure that the .cds file is in the working directory!
```
wgd mcl -s sample.fa --cds --mcl
```
Output is a directory named wgd_blast with a file named `sample.fa.blast.tsv.mcl`. Move this file to the directory youâ€™re working with for easy access
```
mv wgd_blast/sample.fa.blast.tsv.mcl /dir_path
```
Compute Ks distributions. This will output a .tsv file and a .svg file. You can check the Ks distribution via the .tsv file and the generated histograms via the .svg file.
```
wgd ksd sample.fa.blast.tsv.mcl sample.fa
```
We then used the R package [mixtools ver. 1.2.0](https://cran.r-project.org/web/packages/mixtools/mixtools.pdf) (Benaglia et al. 2009) to fit mixture models to the Ks distributions. The code for this can be found in this directory under `ks_plots.R`. 

One-v-one analyses were used to generate estimates of single copy ortholog divergences between two taxa of interest. 
```
wgd mcl --cds --one_v_one -s sample1.fa,sample2.fa 

wgd ksd sample1.fa_sample2.fa.ovo.tsv sample1.fa sample2.fa 
```

## Using Ksrates

Use [ksrates](https://ksrates.readthedocs.io/en/latest/index.html) (Sensalari et al. 2022) to generate adjusted paralog and ortholog Ks plots. The full documentation is listed in the Read the Docs site (linked above) but this is an example. 
```
ksrates init txm.config
ksrates paralogs-ks txm.config --n-threads 20
ksrates orthologs-ks txm.config txm1 txm2 --n-threads 20
ksrates orthologs-ks txm.config txm1 txm3 --n-threads 20 
ksrates orthologs-ks txm.config txm2 txm3 --n-threads 20
ksrates orthologs-analysis txm.config
ksrates plot-orthologs txm.config
ksrates orthologs-adjustment txm.config
ksrates plot-paralogs txm.config
ksrates plot-tree txm.config
ksrates paralogs-analyses txm.config
```

## Phylogenomic Approaches 

Using subsets of transcriptomes based on our hypothesized events from Ks plots, we generated lists of orthogroups that contained at least one copy of each transcriptome of interest. 

```
for file in $(cat OGs_of_interest.txt); do bash get_orthogroups.sh -l taxa.txt -f "$file" -s N -p 0.45;done  
```
Where `OGs_of_interest.txt` is a list of shared OGs (e.g., OGs that are in at least two transcriptomes). OGs in the list generated by `get_orthogroups.sh` were then copied into a new directory. Seqkit was then used to extract only sequences from transcriptomes of interest. 
```
for file in *.fa; do seqkit grep "$file" -r -f taxa.txt -o "$file".out;done 
```
The corresponding CDS for each OG were extracted, aligned, trimmed, and gene trees generated as in the phylogenomic analyses. Treefiles were concatenated into a single file.

MAPS (Li et al. 2015, 2018) was then used to esimate the placement of duplications on a given phylogeny. 

```
maps.pl --l Taxa.list --t Tree.tre --mt 45 --o Event
```

This will generate the empirical distribution of trees across the nodes. To compare to a null and positive distribution, we need to calculate estimaes of gene birth and death rates (see `MAPS.R`). These estimates are used in the `sim.ctl` control file. After editing the control file and generating the time tree, run:
```
perl simulateGeneTrees.3.0_JAP.pl
perl sampleTrees.pl -in simualted_trees.tre -n 1000 -r 100 -out subsample
for file in subsample*; do perl maps.pl --l Taxa.list --t "$file" --o "$file"_out;done
```
To summarize the MAPS results across the null trees, copy them into a single directory and run `summarizeMAPS.py`:
```
python summarizeMAPS.py [number of nodes] [number of trees per analysis] [output name]
```
Put the `*.mapsMeanOut.csv` and `*_subtree.csv` files in the same directory and run `runFisher_Null_JAP.pl`:
```
perl runFisher_Null_JAP.pl
```
Repeat the process with positive simulations, by adding a WGD event on the branch leading to the shared node with evidence of WGD.

## Biased Gene Retention 

To examine how and if genes were differentially retained after WGDs, we created lists of duplicates that were +/- 1SD from the mean putative WGD peak(s) in each transcriptome (see `ks_plots.R`). The output files were then further edited to get a list of paralogs that could then be used to extract the corresponding CDS from each transcriptome for further analyses. 

```
for file in *.tsv; do sed -r 's/^[0-9]*\s//g' "$file" | sed 's/\_\_/\n/g' | sed -r 's/^([A-Za-z])/>\1/g' > "$file"_paralog.list.tsv;done
```

We then extracted the corresponding CDS sequences with `extract_cds.py`. 

```
python extract_cds.py sample_paralog.list.tsv sample.fa.cds 
```

We then used the GOGetter Pipeline (E.B. Sessa, M.S. Barker et al., unpub.) to BLAST each transcriptome and corresponding paralogs to the Araport11 <i>Arabidopsis thaliana </i> protein dataset (Berardini et al. 2004). 

```
perl 0_Get_GO_annotations.pl taxon_list.txt 

for file in $(cat taxon_list.txt); do perl 1_maketable_raw_JAP.pl "$file";done

for file in $(cat taxon_list.txt); do perl 2_maketable_freq_JAP.pl "$file";done

for file in $(cat taxon_list.txt); do sed 's/, RNA binding/ RNA binding/g' "$file" | sed 's/, epigenetic/ epigenetic/g' | cut -d, -f2 > frequencytable_"$file".csv;done 

```

The proption of GO terms in each GO category (as defined by Araport) was visualized in R (see `gene_retention.R`). 


## References 

Zwaenepoel, A., and Van de Peer, Y. wgd - simple command line tools for the analysis of ancient whole genome duplications. Bioinformatics., bty915, https://doi.org/10.1093/bioinformatics/bty915
